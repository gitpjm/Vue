<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue源码分析</title>
</head>
<body>
<div id="box">

</div>
<div>
    <p>hello，<input id='nickName'></p>
    <div id="introduce"></div>
</div>　　　　
<script src="Vue.js"></script>
<script>
    var vue = new Vue({
        "el":"#box",
        data: function () {
            return {
                mssage:"a"
            }
        }
    });

    function a(){}
    {
        a();  //不会执行{} 里面的函数a
    }

    {
        var c = 1;
        function Vue$3() {}
        function  a() { return Vue$3 }
        //"new 执行的a"
        Vue$3.name1 = "123"
    }

    new a();

    /**
     * Check if value is primitive 检查是否是原始值
     */
    function isPrimitive (value) {
        return (
                typeof value === 'string' ||
                typeof value === 'number' ||
                // $flow-disable-line
                typeof value === 'symbol' ||
                typeof value === 'boolean'
        )
    }

    function isObject (obj) {
        return obj !== null && typeof obj === 'object'
    }

    var _toString = Object.prototype.toString; //通过Object.prototype.toString.call()方法，判断某个对象值属于哪种内置类型。

    function toRawType (value) {
        return _toString.call(value).slice(8,-1)
    }

     Array.prototype.slice = function(start,end){
         var result = new Array();
         start = start || 0;
         end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象
        for(var i = start; i < end; i++){
                  result.push(this[i]);
             }
        return result
     }
    // toRawType(arr) 处理之前[Object Object]  call之后 '[object Array]';    slice处理之后Array
    ////slice() -1表示最后一个元素 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。

    //将一个类数组对象转换为真正的数组
    var ad = {'0':'a', '1':'b', '2':'c', length:3};
    function list() {
        return Array.prototype.slice.call(arguments); // arguments 是一个伪数组
    }
    var unboundSlice = Array.prototype.slice;
    var slice = Function.prototype.call.bind(unboundSlice); //先绑定
    //slice(ad)  ["a", "b", "c"]
    //Function.prototype.call(ad).bind(unboundSlice)
    //call 执行slice前函数原型已经绑定了Array.prototype.slice  在执行slice函数 并把其内部的this指向ad
    // 等价于Array.prototype.slice.call(arguments)

    /**
     * Strict object type check. Only returns true
     * for plain JavaScript objects.
     */
    function isPlainObject (obj) {
        return _toString.call(obj) === '[object Object]'
    }

    function isRegExp (v) {
        return _toString.call(v) === '[object RegExp]'
    }

    function isValidArrayIndex (val) {
        var n = parseFloat(String(val));
        return n >= 0 && Math.floor(n) === n && isFinite(val)
    }

    /**
     * Convert a value to a string that is actually rendered. 将值转换为实际呈现的字符串。
     */
    function toString (val) {
        return val == null
                ? ''
                : typeof val === 'object'
                ? JSON.stringify(val, null, 2)
                : String(val)
    }

    JSON.stringify({name:"123",hobby:{ball:"qiulei"}}, null, 2)
    //  JSON.stringify  第2个参数 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，
    // 则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；
    //  JSON.stringify  第3个参数  指定缩进用的空白字符串，用于美化输出（pretty-print）；
    //console.log(JSON.stringify({name:"123",hobby:{ball:"qiulei"}}, null, 2))

    function toNumber (val) {
        var n = parseFloat(val);
        return isNaN(n) ? val : n
    }

    /**
     * Make a map and return a function for checking if a key 绘制一个地图并返回一个函数检查key是否在内置属性里
     Make a map and return a function for checking if a key
     * is in that map.
     */
    function makeMap (
            str,
            expectsLowerCase
    ) {
        var map = Object.create(null);
        var list = str.split(',');
        for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
        }
        return expectsLowerCase
                ? function (val) { return map[val.toLowerCase()]; }
                : function (val) { return map[val]; }
    }
    /**
     * Check if a tag is a built-in tag. 检查标签是否为内置标签。如果是返回true 否返回undefined
     */
    var isBuiltInTag = makeMap('slot,component', true)("component1");
    //isBuiltInTag  true

    /**
     * Check if a attribute is a reserved attribute. 检查属性是否为保留属性。 is a reserved attribute and cannot be used as component prop.
     */
    var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is')("slot");
    //isReservedAttribute true

    /**
     * Remove an item from an array
     */
    function remove (arr, item) {
        if (arr.length) {
            var index = arr.indexOf(item);
            if (index > -1) {
                return arr.splice(index, 1)
                //index 开始删除的下标   1 代表删除的个数
                // 1个参数 index默认从0开始
                // 如果三个参数 中间的代表删除的个数 最后一个是插入的元素
            }
        }
    }
    var arr = ["1","2","3","5"]
    remove(arr,"2")
    //arr ["1","3","5"]

    /*  缓存原型方法, 避免每次去对象的原型找这个hasOwnProperty方法, 减少一丁点性能损耗*/

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    //在这里，只有 hasOwnProperty 能给出正确答案，这在遍历一个对象的属性时是非常必要的。Javascript 中没有其他方法能判断一个属性是定义在对象本身还是继承自原型链。
    //当我们使用 for in loop 来遍历对象时，使用 hasOwnProperty 将会很好地避免来自原型对象扩展所带来的困扰。
    function hasOwn (obj, key) {
        return hasOwnProperty.call(obj, key)
    }
    function As(){
        this.name = "fjals"
    }
    var as = new As()
    As.prototype.n = {n:'123'}
//    console.log(hasOwn(as,"n")) false
//    console.log("n" in as )  true
//    console.log(as.hasOwnProperty("name"))  true  普通写法  每次去hasOwnProperty原型中查找

    /**
     * Create a cached version of a pure function. 创建纯函数的缓存版本。
     利用闭包缓存一个函数执行特定参数的结果, 柯里化, 比如
     执行 var cFn1 = cached( fn1 ); cFn1(2); 第二次调用 cFn1(2)的时候, 就可以利用第一次的结果,
     适合会多次调用一个函数, 而且参数有可能重复的情况
     由于是利用了缓存, 所以传入的函数应该是纯函数, 就是每次如果参数一样, 结果必须一样, 不能是random这样的函数
     */
    function cached (fn) {
        var cache = Object.create(null);
        return (function cachedFn (str) {
            var hit = cache[str];
            //多次调用 缓存结果到hit中
            return hit || (cache[str] = fn(str))
        })
    }

    var camelizeRE = /-(\w)/g; //\w数字 字母 下划线

    var camelize = cached(function (str) {
        return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : ''; })
    });

    // str.replace(reg,function(a,b,c,d){})

    //第一个参数：正则所匹配到的字符；

    //第二个参数：捕获括号所捕获到的字符；

    //第三个参数：正则匹配到的每段字符的第一个字符的索引；

    //第四个参数：用于匹配的字符串主体；

    //camelize("abc-dkf")  //abcDkd
    //camelize("abc-dkf")
    var capitalize = cached(function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1)
    });

    //var str="www.runoob.com!";
    //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
    //document.write(str.slice(4)+"<br>"); // 从第 5 个字符开始截取到末尾
    //document.write(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符


    /**
     * Hyphenate a camelCase string.
     */
    var hyphenateRE = /\B([A-Z])/g;  //\B  括号中边界检测
    var hyphenate = cached(function (str) {
        return str.replace(hyphenateRE, '-$1').toLowerCase() // ? '-$1'
    });
    hyphenate("afAjkDdddDdfs") //af-ajk-dddd-ddfs

    /**
     * Simple bind, faster than native  // 关于bind https://segmentfault.com/a/1190000002662251
     */
    function bind (fn, ctx) {
        function boundFn (a) {
            var l = arguments.length;
            //console.log(arguments)   //arguments.callee  = boundFn 它可以用来递归匿名函数。
            return l
                    ? l > 1 //如果实参数量大于1
                    ? fn.apply(ctx, arguments)
                    : fn.call(ctx, a) //如果实参数量等于1
                    : fn.call(ctx) //l 不存在 无实参
        }
       // var num = 5
       // num ? num > 10 ? num = 8 : num =  0 : num = 9

       // record original fn length 记录原始的形参数量
        boundFn._length = fn.length;
        return boundFn
    }

    this.num = 9;
    var mymodule = {
        num: 81,
        getNum: function() { return this.num; }
    };

    mymodule.getNum(); // 81

    var getNum = mymodule.getNum;
    getNum(); // 9, 因为在这个例子中，"this"指向全局对象

    // 创建一个'this'绑定到module的函数
    var boundGetNum = getNum.bind(mymodule);
    //boundGetNum() // 81

    var boundGetNum1 = bind(getNum,mymodule)(this.num) //this.num 为实参

    //boundGetNum1  81


    /**
     * Convert an Array-like object to a real Array. 将伪数组转化伪数组
     */
    function toArray (list, start) {
        start = start || 0;
        var i = list.length - start;
        var ret = new Array(i);
        while (i--) {    //0 == false
            ret[i] = list[i + start];
        }
        return ret
    }

    /**
     * Mix properties into target object. 属性混和  相当于浅拷贝
     */

    function extend (to, _from) {
        for (var key in _from) {
            to[key] = _from[key];
        }
        return to
    }

    //var cloneObj = JSON.parse(JSON.stringify(obj)); 深拷贝
    // 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果
    function deepClone(initalObj, finalObj) {
        var obj = finalObj || {};
        for (var i in initalObj) {
            var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
            if(prop === obj) {
                continue;
            }
            if (typeof prop === 'object') {
                obj[i] = (prop.constructor === Array) ? [] : {};
                arguments.callee(prop, obj[i]);
            } else {
                obj[i] = prop;
            }
        }
        return obj;
    }
    var str = {};
    var obj = { a: {a: "hello", b: 21} };
    deepClone(obj, str);
    //str.a {a: "hello", b: 21}

    /* Method of Boolean, Number, String*/
    Boolean.prototype.clone = function() { return this.valueOf(); };
    Number.prototype.clone = function() { return this.valueOf(); };
    String.prototype.clone = function() { return this.valueOf(); };

    //关于更多拷贝 https://segmentfault.com/a/1190000000501320


    /**
     * Perform no operation. 不执行操作。noop?
     * Stubbing args to make Flow happy without leaving useless transpiled code
     * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
     */
    function noop (a, b, c) {}

    /**
     * Always return false.
     */
    var no = function (a, b, c) { return false; };

    /**
     * Return same value
     */

    var identity = function (_) { return _; };
    //identity()  undefined

    /**
     * Generate a static keys string from compiler modules.
     */
    function genStaticKeys (modules) {
        return modules.reduce(function (keys, m) {
            return keys.concat(m.staticKeys || [])
        }, []).join(',')
    }

    var klass$11 = {
        staticKeys: ['staticClass']
    };

    var style$11 = {
        staticKeys: ['staticStyle']
    };

    var model$21 = {
        preTransformNode: {}
    };

    var modules$1 = [
        klass$11,
        style$11,
        model$21
    ];

    //console.log(genStaticKeys(modules$1)) //staticClass,staticStyle

    /**
     * Check if two values are loosely equal - that is,
     * if they are plain objects, do they have the same shape?
     * 检查两个值是否松散相等，也就是说，如果它们是普通对象，它们是否具有相同的结构？
     */
    function looseEqual (a, b) {
        if (a === b) { return true }
        var isObjectA = isObject(a);
        var isObjectB = isObject(b);
        if (isObjectA && isObjectB) {
            try {
                var isArrayA = Array.isArray(a);
                var isArrayB = Array.isArray(b);
                if (isArrayA && isArrayB) {
                    return a.length === b.length && a.every(function (e, i) {
                                return looseEqual(e, b[i])
                            })
                    //对数组中的每个元素都执行一次指定的函数（callback），直到此函数返回 false，
                    // 如果发现这个元素，every 将返回 false，如果回调函数对每个元素执行后都返回 true ，every 将返回 true。
                    // 它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略
                } else if (!isArrayA && !isArrayB) {
                    var keysA = Object.keys(a);
                    var keysB = Object.keys(b);
                    return keysA.length === keysB.length && keysA.every(function (key) {
                                return looseEqual(a[key], b[key])
                            })
                } else {
                    /* istanbul ignore next */
                    return false
                }
            } catch (e) {
                /* istanbul ignore next */
                return false
            }
        } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b)
        } else {
            return false
        }
    }
    //looseEqual(["1,2"],["1,2"])  true
    //looseEqual(["1,2"],["1,3"])  false

    function getSelf(n){
        if(n==1){
            return 1
        }
        return n+getSelf(n-1)
    }
    //console.log(getSelf(3)) 6
    //递归是可以利用闭包缓存参数，直道满足外部表达式时return 结束递归

    //问题描述：给两个数，如果两个数相等，最大公约数是其本身。
    // 如果不等，取两个数相减的绝对值和两个数中最小的数比较，相等则为最大公约，不等则继续上面的算法，直到相等。
    var getNum = function (num,num1) {
        if(num === num1) { return num}
        return arguments.callee(Math.abs(num-num1),Math.min(num,num1))  //Math.min.apply(null,mArr) 取数组最小值
    }
    // 关于更多递归https://www.cnblogs.com/YikaJ/p/4263873.html
    var mArr = [1,2,3,4,5,6,7]
    // mArr.splice(Math.random(2.5),1)   1  数组的第一个


    // 查找val是否是数组中的直 并返回相应的下标
    function looseIndexOf (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) { return i }
        }
        return -1
    }
    /**
     * Ensure a function is called only once.
     */
    function once (fn) {
        var called = false;
        return function () {
            if (!called) {
                called = true;
                fn.apply(this, arguments);
            }
        }
    }

    var abcd = once(function a(){console.log(arguments)})
    //abcd(1); 改变called的值  执行了once的回调函数  全局调用this指向window  传递参数argumens
    // 返回Arguments [1, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    //abcd(2)  没有执行 因为此时called为true  利用闭包缓存上一次的结果


    //定义Vue属性

    var SSR_ATTR = 'data-server-rendered';

    var ASSET_TYPES = [
        'component',
        'directive',
        'filter'
    ];

    var LIFECYCLE_HOOKS = [
        'beforeCreate',
        'created',
        'beforeMount',
        'mounted',
        'beforeUpdate',
        'updated',
        'beforeDestroy',
        'destroyed',
        'activated',
        'deactivated',
        'errorCaptured'
    ];

    var config = ({
        /**
         * Option merge strategies (used in core/util/options)
         */
        // $flow-disable-line
        optionMergeStrategies: Object.create(null),

        /**
         * Whether to suppress warnings.
         */
        silent: false,

        /**
         * Show production mode tip message on boot?
         */
        productionTip: "development" !== 'production',

        /**
         * Whether to enable devtools
         */
        devtools: "development" !== 'production',

        /**
         * Whether to record perf
         */
        performance: false,

        /**
         * Error handler for watcher errors
         */
        errorHandler: null,

        /**
         * Warn handler for watcher warns
         */
        warnHandler: null,

        /**
         * Ignore certain custom elements
         */
        ignoredElements: [],

        /**
         * Custom user key aliases for v-on
         */
        // $flow-disable-line
        keyCodes: Object.create(null),

        /**
         * Check if a tag is reserved so that it cannot be registered as a
         * component. This is platform-dependent and may be overwritten.
         */
        isReservedTag: no,

        /**
         * Check if an attribute is reserved so that it cannot be used as a component
         * prop. This is platform-dependent and may be overwritten.
         */
        isReservedAttr: no,

        /**
         * Check if a tag is an unknown element.
         * Platform-dependent.
         */
        isUnknownElement: no,

        /**
         * Get the namespace of an element
         */
        getTagNamespace: noop,

        /**
         * Parse the real tag name for the specific platform.
         */
        parsePlatformTagName: identity,

        /**
         * Check if an attribute must be bound using property, e.g. value
         * Platform-dependent.
         */
        mustUseProp: no,

        /**
         * Exposed for legacy reasons
         */
        _lifecycleHooks: LIFECYCLE_HOOKS
    });

    //console.log(j())// j is not a function

    {  // 花括号  的作用是形成局部作用域  推测（）作用也是如此
        var j = function (){};
        var o = ({name:"123",a:function(){}})
    }

    /**
     * Check if a string starts with $ or _
     */
    function isReserved (str) {
        var c = (str + '').charCodeAt(0);
        return c === 0x24 || c === 0x5F
    }
    // $ 36  _95
    //【0x24 36】 【0x5F 95】
    //【0x10 16】 【0x11 17】  【0x20 32】 【0x30  48】
    //console.log(isReserved("_ds"))  true

    /**
     * Define a property. 定义属性
     */
    function def (obj, key, val, enumerable) {
        Object.defineProperty(obj, key, {
            value: val, //该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
            enumerable: !!enumerable, //当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false
            writable: true, //当且仅当该属性的writable为true时，value才能被赋值运算符改变。表示能不能够重写属性值，默认为false。 对应set和get方法 改写和返回修改后的属性
            configurable: true //总开关，更改跟属性key有关的任意值; false:如果重新对这个属性进行定义的话，会提示出错,同时也不能删除。
        });
    }
    //视图控制器
    var userInfo = {};
    Object.defineProperty(userInfo, "nickName", {
        get: function(){
            return document.getElementById('nickName').value;
        },
        set: function(nick){
            document.getElementById('nickName').value = nick;
        }
    });
    Object.defineProperty(userInfo, "introduce", {
        get: function(){
            return document.getElementById('introduce').innerHTML;
        },
        set: function(introduce){
            document.getElementById('introduce').innerHTML = introduce;
        }
    })
    document.getElementById('nickName').addEventListener("input",function(){
        userInfo.introduce = userInfo.nickName
    })
    userInfo.nickName = "123";
    userInfo.introduce = userInfo.nickName
    //这些值不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，可能要在这之前冻结 防止修改属性 Object.prototype，
    //相关链接 https://www.jianshu.com/p/07ba2b0c8fca  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
    //“key” 赋值 或者 取值的时候会分别触发 set 和 get 对应的函数

    /**
     * Parse simple path.
     */
    var bailRE = /[^\w.$]/;
    // 匹配除了开头数字，字母，下划线和点 ,$ 的，从头开始匹配，匹配一次，test() 如果有满足此种模式的 返回true
    // d..d.^& 匹配了 ^   如果有特殊符号则返回空
    function parsePath (path) {
        if (bailRE.test(path)) {
            return
        }
        var segments = path.split('.');
        return function (obj) {
            for (var i = 0; i < segments.length; i++) {
                if (!obj) { return }
                obj = obj[segments[i]];
            }
            return obj
        }
    }
    var reg = /[^\w.$]/  ///[^ ]/  匹配任何不在指定范围内的任意字符

    //console.log(parsePath("$a")({$a:"123"})) // 123

    // can we use __proto__? 是否可以用__proto__
    var hasProto = '__proto__' in {};  // true

    // Browser environment sniffing  判断所处环境
    var inBrowser = typeof window !== 'undefined';
    var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
    var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
    var isEdge = UA && UA.indexOf('edge/') > 0;
    var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
    var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
    var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

    // Firefox has a "watch" function on Object.prototype...  火狐上对象有watch这个属性
    var nativeWatch = ({}).watch;

    var supportsPassive = false;
    if (inBrowser) {
        try {
            var opts = {};
            Object.defineProperty(opts, 'passive', ({
                get: function get () {
                    /* istanbul ignore next */
                    supportsPassive = true;
                }
            })); // https://github.com/facebook/flow/issues/285
            window.addEventListener('test-passive', null, opts); //?
            //https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
            //浏览器检查 opts 对象上的 passive 值时， supportsPassive 将会被设置为 true；如果不的话它将保持 false。
            // 然后我们调用 addEventListener() 去设置一个指定这些选项的空事件处理器，
            // 这样如果浏览器将第三个参数认定为对象的话，这些选项值就会被检查。
        } catch (e) {}
    }
    //console.log(supportsPassive)  true

    // this needs to be lazy-evaled because vue may be required before
    // vue-server-renderer can set VUE_ENV
    var _isServer;
    var isServerRendering = function () {
        if (_isServer === undefined) {
            /* istanbul ignore if */
            if (!inBrowser && typeof global !== 'undefined') {  //global undefined
                // detect presence of vue-server-renderer and avoid
                // Webpack shimming the process
                _isServer = global['process'].env.VUE_ENV === 'server';
            } else {
                _isServer = false;
            }
        }
        return _isServer
    };

    //isServerRendering()  false

    // detect devtools
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    //devtools  undefined

    /* istanbul ignore next */ //是否是原生自带的函数
    function isNative (Ctor) {
        return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
    }
    //console.log(isNative(Promise))  true

    //ES6 Symbols也是一个集，但它的元素既不是字符串也不是对象。它是ES6的新成员：第七种基本类型。表示独一无二的值
    //http://www.jb51.net/article/89087.htm
    var hasSymbol =
            typeof Symbol !== 'undefined' && isNative(Symbol) &&
            typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys); //Reflect.ownKeys  返回一个包含所有自身属性（不包含继承属性）的数组。

    //console.log(hasSymbol)  true
    var s1 = Symbol("s1");
    var s2 = Symbol("s2");
    // s1 === s2  false

    //Reflect http://www.jb51.net/article/89087.htm
    //要执行一个函数f，并给它传一组参数args， 还要绑定this的话 f.apply(obj, args)
    //但是f的apply可能被重新定义成用户自己的apply了，所以还是这样写比较靠谱：  Function.prototype.apply.call(f, obj, args)
    //Reflect.apply(f, obj, args)

    //避免直接访问 __proto__  ES5提供了 Object.getPrototypeOf(obj) Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)， 这个是新的方法去访问和设置对象的原型：

    var _Set;
    /* istanbul ignore if */ // $flow-disable-line
    if (typeof Set !== 'undefined' && isNative(Set)) {
        // use native Set when available.
        _Set = Set;
    } else {
        // a non-standard Set polyfill that only works with primitive keys.
        _Set = (function () {
            function Set () {
                this.set = Object.create(null);
            }
            Set.prototype.has = function has (key) {
                return this.set[key] === true
            };
            Set.prototype.add = function add (key) {
                this.set[key] = true;
            };
            Set.prototype.clear = function clear () {
                this.set = Object.create(null);
            };

            return Set;
        }());
    }
    // 结合 new _Set使用
    let s = new Set([1,2,3]);
    s.add(5);
    //console.log(s.size); 4
    //console.log(s.has(100)); false

    let d = new _Set();
    d.add(1)
    //console.log(d.has(2))  false

    for(let e of s) {
        //console.log(e); 1 2 3 5
    }
    s.forEach(function(e){
        //console.log(e); 1 2 3 5
    })

    //Map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
    var myMap = new Map();

    var keyString = 'a string',
            keyObj = {},
            keyFunc = function() {};

    // setting the values
    myMap.set(keyString, "value associated with 'a string'");
    myMap.set(keyObj, 'value associated with keyObj');
    myMap.set(keyFunc, 'value associated with keyFunc');

    //myMap.size; // 3

    // getting the values
    myMap.get(keyString);    // "value associated with 'a string'"
    myMap.get(keyObj);       // "value associated with keyObj"
    myMap.get(keyFunc);      // "value associated with keyFunc"
    /*function noop (a, b, c) {}*/
    var warn = noop;
    var tip = noop;
    var generateComponentTrace = (noop); // work around flow check
    var formatComponentName = (noop);

    {
        var hasConsole = typeof console !== 'undefined';
        var classifyRE = /(?:^|[-_])(\w)/g; //a-cda-asf_csd  [a-c]da[-a]sf[_c]sd   （）（） 两个括号表示两个子匹配 或的关系
        var classify = function (str) { return str
                .replace(classifyRE, function (c) { return c.toUpperCase(); })
                .replace(/[-_]/g, ''); }; //将多余的————___替换成空

        warn = function (msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : ''; //generateComponentTrace(vm) undefined

            if (config.warnHandler) {
                config.warnHandler.call(null, msg, vm, trace);
            } else if (hasConsole && (!config.silent)) {
                console.error(("[Vue warn]: " + msg + trace));
            }
        };
        tip = function (msg, vm) {
            if (hasConsole && (!config.silent)) {
                console.warn("[Vue tip]: " + msg + (
                                vm ? generateComponentTrace(vm) : ''
                        ));
            }
        };
        formatComponentName = function (vm, includeFile) {
            if (vm.$root === vm) {
                return '<Root>'
            }
            var options = typeof vm === 'function' && vm.cid != null
                    ? vm.options
                    : vm._isVue
                    ? vm.$options || vm.constructor.options
                    : vm || {};
            var name = options.name || options._componentTag;
            var file = options.__file;
            if (!name && file) {
                var match = file.match(/([^/\\]+)\.vue$/); // ?
                name = match && match[1];
            }

            return (
                    (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
                    (file && includeFile !== false ? (" at " + file) : '')
            )
        };
        var sd = 3;
        //console.log(sd > 5 ? 1 : false ? 10 : 12);  false 12  true  10
        //console.log(formatComponentName(vue))  <Root>

        var repeat = function (str, n) {
            var res = '';
            while (n) {
                if (n % 2 === 1) { res += str; }
                if (n > 1) { str += str; }
                n >>= 1;
            }
            return res
        };

        generateComponentTrace = function (vm) {
            if (vm._isVue && vm.$parent) {
                var tree = [];
                var currentRecursiveSequence = 0;
                while (vm) {
                    if (tree.length > 0) {
                        var last = tree[tree.length - 1];
                        if (last.constructor === vm.constructor) {
                            currentRecursiveSequence++;
                            vm = vm.$parent;
                            continue
                        } else if (currentRecursiveSequence > 0) {
                            tree[tree.length - 1] = [last, currentRecursiveSequence];
                            currentRecursiveSequence = 0;
                        }
                    }
                    tree.push(vm);
                    vm = vm.$parent;
                }
                return '\n\nfound in\n\n' + tree
                                .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
                                        ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
                                        : formatComponentName(vm))); })
                                .join('\n')
            } else {
                return ("\n\n(found in " + (formatComponentName(vm)) + ")")
            }
        };
    }

    var uid = 0;

    /**
     * A dep is an observable that can have multiple
     * directives subscribing to it. DEP是可观察的，可以有多个指令订阅它。
     */
    var Dep = function Dep () {
        this.id = uid++;
        this.subs = [];
    };

    Dep.prototype.addSub = function addSub (sub) {
        this.subs.push(sub);
    };

    Dep.prototype.removeSub = function removeSub (sub) {
        remove(this.subs, sub);
    };

    Dep.prototype.depend = function depend () {
        if (Dep.target) {
            Dep.target.addDep(this); // 是watcher对象下的addDep方法
        }
    };

    Dep.prototype.notify = function notify () {
        // stabilize the subscriber list first
        var subs = this.subs.slice();
        for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();  //sub 是watcher对象的集合
        }
    };

    // the current target watcher being evaluated.
    // this is globally unique because there could be only one
    // watcher being evaluated at any time.
    Dep.target = null;
    var targetStack = [];  //watcher 栈

    function pushTarget (_target) {
        if (Dep.target) { targetStack.push(Dep.target); }
        Dep.target = _target;  //target 是watcher对象
    }

    function popTarget () {
        Dep.target = targetStack.pop();
    }

    // 定义虚拟Dom
    var VNode = function VNode (
            tag,
            data,
            children,
            text,
            elm,
            context,
            componentOptions,
            asyncFactory
    ) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    };

    var prototypeAccessors = { child: { configurable: true } };

    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    prototypeAccessors.child.get = function () {
        return this.componentInstance
    };
    // console.log(VNode.prototype)
    Object.defineProperties( VNode.prototype, prototypeAccessors );

    // 创建空的Dom
    var createEmptyVNode = function (text) {
        if ( text === void 0 ) text = '';

        var node = new VNode();
        node.text = text;
        node.isComment = true;
        return node
    };
    //console.log(createEmptyVNode('div'))   VNode {tag: undefined, data: undefined, children: undefined, text: "div", elm: undefined, …}

   // void方式获取undefined 通用准则 因为undefined在javascript中不是保留字
    function G() {
        var undefined = "hello world";
        //console.log(undefined); // "hello world"
    }
    //console.log(undefined); // undefined
    //除了采用void能保证取到undefined值以外,还有一种方式是通过函数调用
    (function(window, document, undefined) {})(window, document);

    function createTextVNode (val) {
        return new VNode(undefined, undefined, undefined, String(val))
    }
    console.log(createTextVNode(""))








</script>
</body>
</html>