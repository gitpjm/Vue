<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue源码分析</title>
</head>
<body>
<div id="box">
    <aaa></aaa>
</div>

<!--模板可以使用 template标签写到外面，然后在 componets里面调用-->
<template id="temA">
    <div>
        <h3>我是:{{msg}}</h3>
        <add-list :list="Data"></add-list>  <!-- 调用子组件 -->
    </div>
</template>
<div>
    <p>hello，<input id='nickName'></p>
    <div id="introduce"></div>
</div>　　　　
<script src="Vue.js"></script>
<script>
    var vue = new Vue({
        "el":"#box",
        data: function () {
            return {
                mssage:"a"
            }
        },
        components:{
            'aaa':{
                data:function(){
                    return{
                        msg:'父级别组件',
                        Data:"子组件：（父组件传递的数据）"
                    }
                },
                methods:{
                    test:function(){
                        alert("我是父组件")
                    }
                },
                template:'#temA',/*父组件的模板*/
                components:{
                    'addList':{
                        template:"<h3>{{ list }}</h3>",
                        props:{list:String},
                        mounted () {
                            //console.log(this.list,"list")
                        }
                    }
                }
            }
        }
    });
    console.log(vue.constructor.options,"vue.constructor.options")
    console.log(vue,"vue")
    function a(){}
    {
        a();  //不会执行{} 里面的函数a
    }

    {
        var c = 1;
        function Vue$3() {}
        function  a() { return Vue$3 }
        //"new 执行的a"
        Vue$3.name1 = "123"
    }

    new a();

    /**
     * Check if value is primitive 检查是否是原始值
     */
    function isPrimitive (value) {
        return (
                typeof value === 'string' ||
                typeof value === 'number' ||
                // $flow-disable-line
                typeof value === 'symbol' ||
                typeof value === 'boolean'
        )
    }

    function isObject (obj) {
        return obj !== null && typeof obj === 'object'
    }

    var _toString = Object.prototype.toString; //通过Object.prototype.toString.call()方法，判断某个对象值属于哪种内置类型。

    function toRawType (value) {
        return _toString.call(value).slice(8,-1)
    }

     Array.prototype.slice = function(start,end){
         var result = new Array();
         start = start || 0;
         end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象
        for(var i = start; i < end; i++){
                  result.push(this[i]);
             }
        return result
     }
    // toRawType(arr) 处理之前[Object Object]  call之后 '[object Array]';    slice处理之后Array
    ////slice() -1表示最后一个元素 返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。

    //将一个类数组对象转换为真正的数组
    var ad = {'0':'a', '1':'b', '2':'c', length:3};
    function list() {
        return Array.prototype.slice.call(arguments); // arguments 是一个伪数组
    }
    var unboundSlice = Array.prototype.slice;
    var slice = Function.prototype.call.bind(unboundSlice); //先绑定
    //slice(ad)  ["a", "b", "c"]
    //Function.prototype.call(ad).bind(unboundSlice)
    //call 执行slice前函数原型已经绑定了Array.prototype.slice  在执行slice函数 并把其内部的this指向ad
    // 等价于Array.prototype.slice.call(arguments)

    /**
     * Strict object type check. Only returns true
     * for plain JavaScript objects.
     */
    function isPlainObject (obj) {
        return _toString.call(obj) === '[object Object]'
    }

    function isRegExp (v) {
        return _toString.call(v) === '[object RegExp]'
    }

    function isValidArrayIndex (val) {
        var n = parseFloat(String(val));
        return n >= 0 && Math.floor(n) === n && isFinite(val)
    }

    /**
     * Convert a value to a string that is actually rendered. 将值转换为实际呈现的字符串。
     */
    function toString (val) {
        return val == null
                ? ''
                : typeof val === 'object'
                ? JSON.stringify(val, null, 2)
                : String(val)
    }

    JSON.stringify({name:"123",hobby:{ball:"qiulei"}}, null, 2)
    //  JSON.stringify  第2个参数 如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，
    // 则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为null或者未提供，则对象所有的属性都会被序列化；
    //  JSON.stringify  第3个参数  指定缩进用的空白字符串，用于美化输出（pretty-print）；
    //console.log(JSON.stringify({name:"123",hobby:{ball:"qiulei"}}, null, 2))

    function toNumber (val) {
        var n = parseFloat(val);
        return isNaN(n) ? val : n
    }

    /**
     * Make a map and return a function for checking if a key 绘制一个地图并返回一个函数检查key是否在内置属性里
     Make a map and return a function for checking if a key
     * is in that map.
     */
    function makeMap (
            str,
            expectsLowerCase
    ) {
        var map = Object.create(null);
        var list = str.split(',');
        for (var i = 0; i < list.length; i++) {
            map[list[i]] = true;
        }
        return expectsLowerCase
                ? function (val) { return map[val.toLowerCase()]; }
                : function (val) { return map[val]; }
    }
    /**
     * Check if a tag is a built-in tag. 检查标签是否为内置标签。如果是返回true 否返回undefined
     */
    var isBuiltInTag = makeMap('slot,component', true)("component1");
    //isBuiltInTag  true

    /**
     * Check if a attribute is a reserved attribute. 检查属性是否为保留属性。 is a reserved attribute and cannot be used as component prop.
     */
    var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is')("slot");
    //isReservedAttribute true

    /**
     * Remove an item from an array
     */
    function remove (arr, item) {
        if (arr.length) {
            var index = arr.indexOf(item);
            if (index > -1) {
                return arr.splice(index, 1)
                //index 开始删除的下标   1 代表删除的个数
                // 1个参数 index默认从0开始
                // 如果三个参数 中间的代表删除的个数 最后一个是插入的元素
            }
        }
    }
    var arr = ["1","2","3","5"]
    remove(arr,"2")
    //arr ["1","3","5"]

    /*  缓存原型方法, 避免每次去对象的原型找这个hasOwnProperty方法, 减少一丁点性能损耗*/

    var hasOwnProperty = Object.prototype.hasOwnProperty;
    //在这里，只有 hasOwnProperty 能给出正确答案，这在遍历一个对象的属性时是非常必要的。Javascript 中没有其他方法能判断一个属性是定义在对象本身还是继承自原型链。
    //当我们使用 for in loop 来遍历对象时，使用 hasOwnProperty 将会很好地避免来自原型对象扩展所带来的困扰。
    function hasOwn (obj, key) {
        return hasOwnProperty.call(obj, key)
    }
    function As(){
        this.name = "fjals"
    }
    var as = new As()
    As.prototype.n = {n:'123'}
//    console.log(hasOwn(as,"n")) false
//    console.log("n" in as )  true
//    console.log(as.hasOwnProperty("name"))  true  普通写法  每次去hasOwnProperty原型中查找

    /**
     * Create a cached version of a pure function. 创建纯函数的缓存版本。
     利用闭包缓存一个函数执行特定参数的结果, 柯里化, 比如
     执行 var cFn1 = cached( fn1 ); cFn1(2); 第二次调用 cFn1(2)的时候, 就可以利用第一次的结果,
     适合会多次调用一个函数, 而且参数有可能重复的情况
     由于是利用了缓存, 所以传入的函数应该是纯函数, 就是每次如果参数一样, 结果必须一样, 不能是random这样的函数
     */
    function cached (fn) {
        var cache = Object.create(null);
        return (function cachedFn (str) {
            var hit = cache[str];
            //多次调用 缓存结果到hit中
            return hit || (cache[str] = fn(str))
        })
    }

    var camelizeRE = /-(\w)/g; //\w数字 字母 下划线

    var camelize = cached(function (str) {
        return str.replace(camelizeRE, function (_, c) {return c ? c.toUpperCase() : ''; })
    });

    // str.replace(reg,function(a,b,c,d){})

    //第一个参数：正则所匹配到的字符；

    //第二个参数：捕获括号所捕获到的字符；

    //第三个参数：正则匹配到的每段字符的第一个字符的索引；

    //第四个参数：用于匹配的字符串主体；

    //camelize("abc-dkf")  //abcDkd
    //camelize("abc-dkf")
    var capitalize = cached(function (str) {
        return str.charAt(0).toUpperCase() + str.slice(1)
    });

    //var str="www.runoob.com!";
    //返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。
    //document.write(str.slice(4)+"<br>"); // 从第 5 个字符开始截取到末尾
    //document.write(str.slice(4,10)); // 从第 5 个字符开始截取到第10个字符


    /**
     * Hyphenate a camelCase string.
     */
    var hyphenateRE = /\B([A-Z])/g;  //\B  括号中边界检测
    var hyphenate = cached(function (str) {
        return str.replace(hyphenateRE, '-$1').toLowerCase() // ? '-$1'
    });
    hyphenate("afAjkDdddDdfs") //af-ajk-dddd-ddfs

    /**
     * Simple bind, faster than native  // 关于bind https://segmentfault.com/a/1190000002662251
     */
    function bind (fn, ctx) {
        function boundFn (a) {
            var l = arguments.length;
            //console.log(arguments)   //arguments.callee  = boundFn 它可以用来递归匿名函数。
            return l
                    ? l > 1 //如果实参数量大于1
                    ? fn.apply(ctx, arguments)
                    : fn.call(ctx, a) //如果实参数量等于1
                    : fn.call(ctx) //l 不存在 无实参
        }
       // var num = 5
       // num ? num > 10 ? num = 8 : num =  0 : num = 9

       // record original fn length 记录原始的形参数量
        boundFn._length = fn.length;
        return boundFn
    }

    this.num = 9;
    var mymodule = {
        num: 81,
        getNum: function() { return this.num; }
    };

    mymodule.getNum(); // 81

    var getNum = mymodule.getNum;
    getNum(); // 9, 因为在这个例子中，"this"指向全局对象

    // 创建一个'this'绑定到module的函数
    var boundGetNum = getNum.bind(mymodule);
    //boundGetNum() // 81

    var boundGetNum1 = bind(getNum,mymodule)(this.num) //this.num 为实参

    //boundGetNum1  81


    /**
     * Convert an Array-like object to a real Array. 将伪数组转化伪数组
     */
    function toArray (list, start) {
        start = start || 0;
        var i = list.length - start;
        var ret = new Array(i);
        while (i--) {    //0 == false
            ret[i] = list[i + start];
        }
        return ret
    }

    /**
     * Mix properties into target object. 属性混和  相当于浅拷贝
     */

    function extend (to, _from) {
        for (var key in _from) {
            to[key] = _from[key];
        }
        return to
    }

    //var cloneObj = JSON.parse(JSON.stringify(obj)); 深拷贝
    // 直接使用var newObj = Object.create(oldObj)，可以达到深拷贝的效果
    function deepClone(initalObj, finalObj) {
        var obj = finalObj || {};
        for (var i in initalObj) {
            var prop = initalObj[i];        // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
            if(prop === obj) {
                continue;
            }
            if (typeof prop === 'object') {
                obj[i] = (prop.constructor === Array) ? [] : {};
                arguments.callee(prop, obj[i]);
            } else {
                obj[i] = prop;
            }
        }
        return obj;
    }
    var str = {};
    var obj = { a: {a: "hello", b: 21} };
    deepClone(obj, str);
    //str.a {a: "hello", b: 21}

    /* Method of Boolean, Number, String*/
    Boolean.prototype.clone = function() { return this.valueOf(); };
    Number.prototype.clone = function() { return this.valueOf(); };
    String.prototype.clone = function() { return this.valueOf(); };

    //关于更多拷贝 https://segmentfault.com/a/1190000000501320


    /**
     * Perform no operation. 不执行操作。noop?
     * Stubbing args to make Flow happy without leaving useless transpiled code
     * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
     */
    function noop (a, b, c) {}

    /**
     * Always return false.
     */
    var no = function (a, b, c) { return false; };

    /**
     * Return same value
     */

    var identity = function (_) { return _; };
    //identity()  undefined

    /**
     * Generate a static keys string from compiler modules.
     */
    function genStaticKeys (modules) {
        return modules.reduce(function (keys, m) {
            return keys.concat(m.staticKeys || [])
        }, []).join(',')
    }

    var klass$11 = {
        staticKeys: ['staticClass']
    };

    var style$11 = {
        staticKeys: ['staticStyle']
    };

    var model$21 = {
        preTransformNode: {}
    };

    var modules$1 = [
        klass$11,
        style$11,
        model$21
    ];

    //console.log(genStaticKeys(modules$1)) //staticClass,staticStyle

    /**
     * Check if two values are loosely equal - that is,
     * if they are plain objects, do they have the same shape?
     * 检查两个值是否松散相等，也就是说，如果它们是普通对象，它们是否具有相同的结构？
     */
    function looseEqual (a, b) {
        if (a === b) { return true }
        var isObjectA = isObject(a);
        var isObjectB = isObject(b);
        if (isObjectA && isObjectB) {
            try {
                var isArrayA = Array.isArray(a);
                var isArrayB = Array.isArray(b);
                if (isArrayA && isArrayB) {
                    return a.length === b.length && a.every(function (e, i) {
                                return looseEqual(e, b[i])
                            })
                    //对数组中的每个元素都执行一次指定的函数（callback），直到此函数返回 false，
                    // 如果发现这个元素，every 将返回 false，如果回调函数对每个元素执行后都返回 true ，every 将返回 true。
                    // 它只对数组中的非空元素执行指定的函数，没有赋值或者已经删除的元素将被忽略
                } else if (!isArrayA && !isArrayB) {
                    var keysA = Object.keys(a);
                    var keysB = Object.keys(b);
                    return keysA.length === keysB.length && keysA.every(function (key) {
                                return looseEqual(a[key], b[key])
                            })
                } else {
                    /* istanbul ignore next */
                    return false
                }
            } catch (e) {
                /* istanbul ignore next */
                return false
            }
        } else if (!isObjectA && !isObjectB) {
            return String(a) === String(b)
        } else {
            return false
        }
    }
    //looseEqual(["1,2"],["1,2"])  true
    //looseEqual(["1,2"],["1,3"])  false

    function getSelf(n){
        if(n==1){
            return 1
        }
        return n+getSelf(n-1)
    }
    //console.log(getSelf(3)) 6
    //递归是可以利用闭包缓存参数，直道满足外部表达式时return 结束递归

    //问题描述：给两个数，如果两个数相等，最大公约数是其本身。
    // 如果不等，取两个数相减的绝对值和两个数中最小的数比较，相等则为最大公约，不等则继续上面的算法，直到相等。
    var getNum = function (num,num1) {
        if(num === num1) { return num}
        return arguments.callee(Math.abs(num-num1),Math.min(num,num1))  //Math.min.apply(null,mArr) 取数组最小值
    }
    // 关于更多递归https://www.cnblogs.com/YikaJ/p/4263873.html
    var mArr = [1,2,3,4,5,6,7]
    // mArr.splice(Math.random(2.5),1)   1  数组的第一个


    // 查找val是否是数组中的直 并返回相应的下标
    function looseIndexOf (arr, val) {
        for (var i = 0; i < arr.length; i++) {
            if (looseEqual(arr[i], val)) { return i }
        }
        return -1
    }
    /**
     * Ensure a function is called only once.
     */
    function once (fn) {
        var called = false;
        return function () {
            if (!called) {
                called = true;
                fn.apply(this, arguments);
            }
        }
    }

    var abcd = once(function a(){console.log(arguments)})
    //abcd(1); 改变called的值  执行了once的回调函数  全局调用this指向window  传递参数argumens
    // 返回Arguments [1, callee: ƒ, Symbol(Symbol.iterator): ƒ]
    //abcd(2)  没有执行 因为此时called为true  利用闭包缓存上一次的结果


    //定义Vue属性

    var SSR_ATTR = 'data-server-rendered';

    var ASSET_TYPES = [
        'component',
        'directive',
        'filter'
    ];

    var LIFECYCLE_HOOKS = [
        'beforeCreate',
        'created',
        'beforeMount',
        'mounted',
        'beforeUpdate',
        'updated',
        'beforeDestroy',
        'destroyed',
        'activated',
        'deactivated',
        'errorCaptured'
    ];

    var config = ({
        /**
         * Option merge strategies (used in core/util/options)
         */
        // $flow-disable-line
        optionMergeStrategies: Object.create(null),

        /**
         * Whether to suppress warnings.
         */
        silent: false,

        /**
         * Show production mode tip message on boot?
         */
        productionTip: "development" !== 'production',

        /**
         * Whether to enable devtools
         */
        devtools: "development" !== 'production',

        /**
         * Whether to record perf
         */
        performance: false,

        /**
         * Error handler for watcher errors
         */
        errorHandler: null,

        /**
         * Warn handler for watcher warns
         */
        warnHandler: null,

        /**
         * Ignore certain custom elements
         */
        ignoredElements: [],

        /**
         * Custom user key aliases for v-on
         */
        // $flow-disable-line
        keyCodes: Object.create(null),

        /**
         * Check if a tag is reserved so that it cannot be registered as a
         * component. This is platform-dependent and may be overwritten.
         */
        isReservedTag: no,

        /**
         * Check if an attribute is reserved so that it cannot be used as a component
         * prop. This is platform-dependent and may be overwritten.
         */
        isReservedAttr: no,

        /**
         * Check if a tag is an unknown element.
         * Platform-dependent.
         */
        isUnknownElement: no,

        /**
         * Get the namespace of an element
         */
        getTagNamespace: noop,

        /**
         * Parse the real tag name for the specific platform.
         */
        parsePlatformTagName: identity,

        /**
         * Check if an attribute must be bound using property, e.g. value
         * Platform-dependent.
         */
        mustUseProp: no,

        /**
         * Exposed for legacy reasons
         */
        _lifecycleHooks: LIFECYCLE_HOOKS
    });

    //console.log(j())// j is not a function

    {  // 花括号  的作用是形成局部作用域  推测（）作用也是如此
        var j = function (){};
        var o = ({name:"123",a:function(){}})
    }

    /**
     * Check if a string starts with $ or _
     */
    function isReserved (str) {
        var c = (str + '').charCodeAt(0);
        return c === 0x24 || c === 0x5F
    }
    // $ 36  _95
    //【0x24 36】 【0x5F 95】
    //【0x10 16】 【0x11 17】  【0x20 32】 【0x30  48】
    //console.log(isReserved("_ds"))  true

    /**
     * Define a property. 定义属性
     */
    function def (obj, key, val, enumerable) {
        Object.defineProperty(obj, key, {
            value: val, //该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。
            enumerable: !!enumerable, //当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false
            writable: true, //当且仅当该属性的writable为true时，value才能被赋值运算符改变。表示能不能够重写属性值，默认为false。 对应set和get方法 改写和返回修改后的属性
            configurable: true //总开关，更改跟属性key有关的任意值; false:如果重新对这个属性进行定义的话，会提示出错,同时也不能删除。
        });
    }
    //视图控制器
    var userInfo = {};
    Object.defineProperty(userInfo, "nickName", {
        get: function(){
            return document.getElementById('nickName').value;
        },
        set: function(nick){
            document.getElementById('nickName').value = nick;
        }
    });
    Object.defineProperty(userInfo, "introduce", {
        get: function(){
            return document.getElementById('introduce').innerHTML;
        },
        set: function(introduce){
            document.getElementById('introduce').innerHTML = introduce;
        }
    })
    document.getElementById('nickName').addEventListener("input",function(){
        userInfo.introduce = userInfo.nickName
    })
    userInfo.nickName = "123";
    userInfo.introduce = userInfo.nickName
    //这些值不一定是自身属性，如果是继承来的也要考虑。为了确认保留这些默认值，可能要在这之前冻结 防止修改属性 Object.prototype，
    //相关链接 https://www.jianshu.com/p/07ba2b0c8fca  https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty
    //“key” 赋值 或者 取值的时候会分别触发 set 和 get 对应的函数

    /**
     * Parse simple path.
     */
    var bailRE = /[^\w.$]/;
    // 匹配除了开头数字，字母，下划线和点 ,$ 的，从头开始匹配，匹配一次，test() 如果有满足此种模式的 返回true
    // d..d.^& 匹配了 ^   如果有特殊符号则返回空
    function parsePath (path) {
        if (bailRE.test(path)) {
            return
        }
        var segments = path.split('.');
        return function (obj) {
            for (var i = 0; i < segments.length; i++) {
                if (!obj) { return }
                obj = obj[segments[i]];
            }
            return obj
        }
    }
    var reg = /[^\w.$]/  ///[^ ]/  匹配任何不在指定范围内的任意字符

    //console.log(parsePath("$a")({$a:"123"})) // 123

    // can we use __proto__? 是否可以用__proto__
    var hasProto = '__proto__' in {};  // true

    // Browser environment sniffing  判断所处环境
    var inBrowser = typeof window !== 'undefined';
    var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
    var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
    var UA = inBrowser && window.navigator.userAgent.toLowerCase();
    var isIE = UA && /msie|trident/.test(UA);
    var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
    var isEdge = UA && UA.indexOf('edge/') > 0;
    var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
    var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
    var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

    // Firefox has a "watch" function on Object.prototype...  火狐上对象有watch这个属性
    var nativeWatch = ({}).watch;

    var supportsPassive = false;
    if (inBrowser) {
        try {
            var opts = {};
            Object.defineProperty(opts, 'passive', ({
                get: function get () {
                    /* istanbul ignore next */
                    supportsPassive = true;
                }
            })); // https://github.com/facebook/flow/issues/285
            window.addEventListener('test-passive', null, opts); //?
            //https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
            //浏览器检查 opts 对象上的 passive 值时， supportsPassive 将会被设置为 true；如果不的话它将保持 false。
            // 然后我们调用 addEventListener() 去设置一个指定这些选项的空事件处理器，
            // 这样如果浏览器将第三个参数认定为对象的话，这些选项值就会被检查。
        } catch (e) {}
    }
    //console.log(supportsPassive)  true

    // this needs to be lazy-evaled because vue may be required before
    // vue-server-renderer can set VUE_ENV
    var _isServer;
    var isServerRendering = function () {
        if (_isServer === undefined) {
            /* istanbul ignore if */
            if (!inBrowser && typeof global !== 'undefined') {  //global undefined
                // detect presence of vue-server-renderer and avoid
                // Webpack shimming the process
                _isServer = global['process'].env.VUE_ENV === 'server';
            } else {
                _isServer = false;
            }
        }
        return _isServer
    };

    //isServerRendering()  false

    // detect devtools
    var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
    //devtools  undefined

    /* istanbul ignore next */ //是否是原生自带的函数
    function isNative (Ctor) {
        return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
    }
    //console.log(isNative(Promise))  true

    //ES6 Symbols也是一个集，但它的元素既不是字符串也不是对象。它是ES6的新成员：第七种基本类型。表示独一无二的值
    //http://www.jb51.net/article/89087.htm
    var hasSymbol =
            typeof Symbol !== 'undefined' && isNative(Symbol) &&
            typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys); //Reflect.ownKeys  返回一个包含所有自身属性（不包含继承属性）的数组。

    //console.log(hasSymbol)  true
    var s1 = Symbol("s1");
    var s2 = Symbol("s2");
    // s1 === s2  false

    //Reflect http://www.jb51.net/article/89087.htm
    //要执行一个函数f，并给它传一组参数args， 还要绑定this的话 f.apply(obj, args)
    //但是f的apply可能被重新定义成用户自己的apply了，所以还是这样写比较靠谱：  Function.prototype.apply.call(f, obj, args)
    //Reflect.apply(f, obj, args)

    //避免直接访问 __proto__  ES5提供了 Object.getPrototypeOf(obj) Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)， 这个是新的方法去访问和设置对象的原型：

    var _Set;
    /* istanbul ignore if */ // $flow-disable-line
    if (typeof Set !== 'undefined' && isNative(Set)) {
        // use native Set when available.
        _Set = Set;
    } else {
        // a non-standard Set polyfill that only works with primitive keys.
        _Set = (function () {
            function Set () {
                this.set = Object.create(null);
            }
            Set.prototype.has = function has (key) {
                return this.set[key] === true
            };
            Set.prototype.add = function add (key) {
                this.set[key] = true;
            };
            Set.prototype.clear = function clear () {
                this.set = Object.create(null);
            };

            return Set;
        }());
    }
    // 结合 new _Set使用
    let s = new Set([1,2,3]);
    s.add(5);
    //console.log(s.size); 4
    //console.log(s.has(100)); false

    let d = new _Set();
    d.add(1)
    //console.log(d.has(2))  false

    for(let e of s) {
        //console.log(e); 1 2 3 5
    }
    s.forEach(function(e){
        //console.log(e); 1 2 3 5
    })

    //Map https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
    var myMap = new Map();

    var keyString = 'a string',
            keyObj = {},
            keyFunc = function() {};

    // setting the values
    myMap.set(keyString, "value associated with 'a string'");
    myMap.set(keyObj, 'value associated with keyObj');
    myMap.set(keyFunc, 'value associated with keyFunc');

    //myMap.size; // 3

    // getting the values
    myMap.get(keyString);    // "value associated with 'a string'"
    myMap.get(keyObj);       // "value associated with keyObj"
    myMap.get(keyFunc);      // "value associated with keyFunc"
    /*function noop (a, b, c) {}*/
    var warn = noop;
    var tip = noop;
    var generateComponentTrace = (noop); // work around flow check
    var formatComponentName = (noop);

    {
        var hasConsole = typeof console !== 'undefined';
        var classifyRE = /(?:^|[-_])(\w)/g; //a-cda-asf_csd  [a-c]da[-a]sf[_c]sd   （）（） 两个括号表示两个子匹配 或的关系
        var classify = function (str) { return str
                .replace(classifyRE, function (c) { return c.toUpperCase(); })
                .replace(/[-_]/g, ''); }; //将多余的————___替换成空

        warn = function (msg, vm) {
            var trace = vm ? generateComponentTrace(vm) : ''; //generateComponentTrace(vm) undefined

            if (config.warnHandler) {
                config.warnHandler.call(null, msg, vm, trace);
            } else if (hasConsole && (!config.silent)) {
                console.error(("[Vue warn]: " + msg + trace));
            }
        };
        tip = function (msg, vm) {
            if (hasConsole && (!config.silent)) {
                console.warn("[Vue tip]: " + msg + (
                                vm ? generateComponentTrace(vm) : ''
                        ));
            }
        };
        formatComponentName = function (vm, includeFile) {
            if (vm.$root === vm) {
                return '<Root>'
            }
            var options = typeof vm === 'function' && vm.cid != null
                    ? vm.options
                    : vm._isVue
                    ? vm.$options || vm.constructor.options
                    : vm || {};
            var name = options.name || options._componentTag;
            var file = options.__file;
            if (!name && file) {
                var match = file.match(/([^/\\]+)\.vue$/); // ?
                name = match && match[1];
            }

            return (
                    (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
                    (file && includeFile !== false ? (" at " + file) : '')
            )
        };
        var sd = 3;
        //console.log(sd > 5 ? 1 : false ? 10 : 12);  false 12  true  10
        //console.log(formatComponentName(vue))  <Root>

        var repeat = function (str, n) {
            var res = '';
            while (n) {
                if (n % 2 === 1) { res += str; }
                if (n > 1) { str += str; }
                n >>= 1;
            }
            return res
        };

        generateComponentTrace = function (vm) {
            if (vm._isVue && vm.$parent) {
                var tree = [];
                var currentRecursiveSequence = 0;
                while (vm) {
                    if (tree.length > 0) {
                        var last = tree[tree.length - 1];
                        if (last.constructor === vm.constructor) {
                            currentRecursiveSequence++;
                            vm = vm.$parent;
                            continue
                        } else if (currentRecursiveSequence > 0) {
                            tree[tree.length - 1] = [last, currentRecursiveSequence];
                            currentRecursiveSequence = 0;
                        }
                    }
                    tree.push(vm);
                    vm = vm.$parent;
                }
                return '\n\nfound in\n\n' + tree
                                .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
                                        ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
                                        : formatComponentName(vm))); })
                                .join('\n')
            } else {
                return ("\n\n(found in " + (formatComponentName(vm)) + ")")
            }
        };
    }

    var uid = 0;

    /**
     * A dep is an observable that can have multiple
     * directives subscribing to it. DEP是可观察的，可以有多个指令订阅它。 消息订阅器，拥有收集订阅者、发布更新的功能。
     */
    var Dep = function Dep () {
        this.id = uid++;
        this.subs = [];
    };

    Dep.prototype.addSub = function addSub (sub) {
        this.subs.push(sub);
    };

    Dep.prototype.removeSub = function removeSub (sub) {
        remove(this.subs, sub);
    };

    Dep.prototype.depend = function depend () {
        if (Dep.target) {
            Dep.target.addDep(this); // 是watcher对象下的addDep方法
        }
    };

    Dep.prototype.notify = function notify () {
        // stabilize the subscriber list first
        var subs = this.subs.slice();
        for (var i = 0, l = subs.length; i < l; i++) {
            subs[i].update();  //sub 是watcher对象的集合
        }
    };

    // the current target watcher being evaluated.
    // this is globally unique because there could be only one
    // watcher being evaluated at any time.
    Dep.target = null;
    var targetStack = [];  //watcher 栈

    function pushTarget (_target) {
        if (Dep.target) { targetStack.push(Dep.target); }
        Dep.target = _target;  //target 是watcher对象
    }

    function popTarget () {
        Dep.target = targetStack.pop();
    }

    // 定义虚拟Dom
    var VNode = function VNode (
            tag,
            data,
            children,
            text,
            elm,
            context,
            componentOptions,
            asyncFactory
    ) {
        this.tag = tag;
        this.data = data;
        this.children = children;
        this.text = text;
        this.elm = elm;
        this.ns = undefined;
        this.context = context;
        this.fnContext = undefined;
        this.fnOptions = undefined;
        this.fnScopeId = undefined;
        this.key = data && data.key;
        this.componentOptions = componentOptions;
        this.componentInstance = undefined;
        this.parent = undefined;
        this.raw = false;
        this.isStatic = false;
        this.isRootInsert = true;
        this.isComment = false;
        this.isCloned = false;
        this.isOnce = false;
        this.asyncFactory = asyncFactory;
        this.asyncMeta = undefined;
        this.isAsyncPlaceholder = false;
    };

    var prototypeAccessors = { child: { configurable: true } };

    // DEPRECATED: alias for componentInstance for backwards compat.
    /* istanbul ignore next */
    prototypeAccessors.child.get = function () {
        return this.componentInstance
    };
    // console.log(VNode.prototype) VNode {tag: undefined, data: undefined, children: undefined, text: "", elm: undefined, …}
    Object.defineProperties( VNode.prototype, prototypeAccessors );

    // 创建空的Dom
    var createEmptyVNode = function (text) {
        if ( text === void 0 ) text = '';

        var node = new VNode();
        node.text = text;
        node.isComment = true;
        return node
    };
    //console.log(createEmptyVNode('div'))   VNode {tag: undefined, data: undefined, children: undefined, text: "div", elm: undefined, …}

   // void方式获取undefined 通用准则 因为undefined在javascript中不是保留字
    function G() {
        var undefined = "hello world";
        //console.log(undefined); // "hello world"
    }
    //console.log(undefined); // undefined
    //除了采用void能保证取到undefined值以外,还有一种方式是通过函数调用
    (function(window, document, undefined) {})(window, document);

    function createTextVNode (val) {
        return new VNode(undefined, undefined, undefined, String(val))
    }
    // console.log(createTextVNode(""))

    // optimized shallow clone
    // used for static nodes and slot nodes because they may be reused across
    // multiple renders, cloning them avoids errors when DOM manipulations rely
    // on their elm reference.
    function cloneVNode (vnode, deep) {
        var componentOptions = vnode.componentOptions;
        var cloned = new VNode(
                vnode.tag,
                vnode.data,
                vnode.children,
                vnode.text,
                vnode.elm,
                vnode.context,
                componentOptions,
                vnode.asyncFactory
        );
        cloned.ns = vnode.ns;
        cloned.isStatic = vnode.isStatic;
        cloned.key = vnode.key;
        cloned.isComment = vnode.isComment;
        cloned.fnContext = vnode.fnContext;
        cloned.fnOptions = vnode.fnOptions;
        cloned.fnScopeId = vnode.fnScopeId;
        cloned.isCloned = true;
        if (deep) {
            if (vnode.children) {
                cloned.children = cloneVNodes(vnode.children, true);
            }
            if (componentOptions && componentOptions.children) {
                componentOptions.children = cloneVNodes(componentOptions.children, true);
            }
        }
        return cloned
    }

    function cloneVNodes (vnodes, deep) {
        var len = vnodes.length;
        var res = new Array(len);
        for (var i = 0; i < len; i++) {
            res[i] = cloneVNode(vnodes[i], deep);
        }
        return res
    }

    /*
     * not type checking this file because flow doesn't play well with
     * dynamically accessing methods on Array prototype
     */

    var arrayProto = Array.prototype;
    // arrayProto  [constructor: ƒ, concat: ƒ, pop: ƒ, push: ƒ, shift: ƒ, …]
    var arrayMethods = Object.create(arrayProto); //arrayMethods  //Array {}
    [
        'push',
        'pop',
        'shift',
        'unshift',
        'splice',
        'sort',
        'reverse'
    ].forEach(function (method) {
        // cache original method  这里是原生Array的原型方法
        var original = arrayProto[method];
        def(arrayMethods, method, function mutator () {  // arrayMethods.method = function mutaor(){}
            var args = [], len = arguments.length;
            while ( len-- ) args[ len ] = arguments[ len ];
            // console.log(this)  ["1", "2", "3", "1", "2", "3", __ob__: Observer]
            // console.log(original)  ƒ push() { [native code] }
            var result = original.apply(this, args); // 原生Array的原型方法 例如push.apply(this,args); 改变push内部的this指向调用这个方法的数组，参数argus
            // console.log(this)  ["1", "2", "3", "1", "2", "3", "12", __ob__: Observer]
            // result 7
            var ob = this.__ob__;  //在Observer  def(value, '__ob__', this);  把数组（value）定义了__ob__ 属性  值为 Observer
            var inserted;
            switch (method) {
                case 'push':
                case 'unshift':  //添加  取出添加的元素 并监听变化
                    inserted = args;
                    break
                case 'splice':
                    inserted = args.slice(2); // 取出插入的元素 并监听变化
                    break
            }
            if (inserted) { ob.observeArray(inserted); }
            // notify change 通知变化
            ob.dep.notify();
            return result
        });
    });

    var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

    /**
     * By default, when a reactive property is set, the new value is
     * also converted to become reactive. However when passing down props,
     * we don't want to force conversion because the value may be a nested value
     * under a frozen data structure. Converting it would defeat the optimization.
     */
    var observerState = {
        shouldConvert: true
    };

    /**
     * Observer class that are attached to each observed  定义观察者 一旦数据发生改变 就会调用get和set方法 收集相关依赖 并且更新
     * object. Once attached, the observer converts target
     * object's property keys into getter/setters that
     * collect dependencies and dispatches updates.
     */
    var Observer = function Observer (value) {
        //console.log(this)
        this.value = value;
        this.dep = new Dep();
        this.vmCount = 0;
        def(value, '__ob__', this); // 把要观察的对象value 绑定key：__ob__ val：Observer对象
        if (Array.isArray(value)) {
            var augment = hasProto  //true
                    ? protoAugment
                    : copyAugment;
            augment(value, arrayMethods, arrayKeys);
            this.observeArray(value);
        } else {
            this.walk(value);
        }
    };

    /**
     * Walk through each property and convert them into  遍历每个属性转化到getter/setters方法，只适用于对象
     * getter/setters. This method should only be called when
     * value type is Object.
     */
    Observer.prototype.walk = function walk (obj) {
        var keys = Object.keys(obj);
        for (var i = 0; i < keys.length; i++) {
            defineReactive(obj, keys[i], obj[keys[i]]);
        }
    };

    /**
     * Observe a list of Array items.
     */
    Observer.prototype.observeArray = function observeArray (items) {
        for (var i = 0, l = items.length; i < l; i++) {
            observe(items[i]);
        }
    };

    // helpers

    /**
     * Augment an target Object or Array by intercepting
     * the prototype chain using __proto__
     */
    function protoAugment (target, src, keys) {   //target ： value 要监听的数组  src ： arrayMethods 这个空数组的属性上定义了我们封装好的push等方法
        /* eslint-disable no-proto */
        target.__proto__ = src;  //// 将我们要监听的数组的原型指针指向上面定义的空数组对象  //查找机制是顺着原型链依次往下找 空数组的第一条原型链是定义好的方法 然后再是数组原生的方法
        /* eslint-enable no-proto */
    }

    /**
     * Augment an target Object or Array by defining
     * hidden properties.
     */
    /* istanbul ignore next */
    function copyAugment (target, src, keys) {
        for (var i = 0, l = keys.length; i < l; i++) {
            var key = keys[i];
            def(target, key, src[key]);
        }
    }
    /**
     * Attempt to create an observer instance for a value, 试图创建一个值的观察者实例，
     * returns the new observer if successfully observed, 如果成功观察，则返回新的观察者，
     * or the existing observer if the value already has one. 或已经存在的观察
     */

    function observe (value, asRootData) {
        if (!isObject(value) || value instanceof VNode) {
            // object instanceof constructor instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链
            // 检测value是否和vNode共用一条原型链 value = new VNode()   value instanceof VNode  true
            return
        }
        var ob;
        if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) { // the existing observer if the value already has one.  def(value, '__ob__', this);
            ob = value.__ob__;
        } else if (
                observerState.shouldConvert &&  // true
                !isServerRendering() && //true
                (Array.isArray(value) || isPlainObject(value)) &&
                Object.isExtensible(value) &&  // The Object.isExtensible() method determines if an object is extensible (whether it can have new properties added to it).
                !value._isVue // true
        ) {
            ob = new Observer(value);
        }
        if (asRootData && ob) {
            ob.vmCount++;
        }
        return ob
    }
    var arr = ['1','2','3','1','2','3']
    var obs = new Observer(arr)
    // obs Observer {value: Array(6), dep: Dep, vmCount: 0}
    var newLength = obs.value.splice(2,1,"32232"); //array.splice(index,howmany,item1,.....,itemX)
    // obs.value  ["1", "2", "32232", "1", "2", "3", __ob__: Observer]
    //简化版vue数组 https://www.cnblogs.com/Darlietoothpaste/p/6682407.html


    /**
     * Define a reactive property on an Object.
     */
    function defineReactive (
            obj,
            key,
            val,
            customSetter,
            shallow
    ) {
        var dep = new Dep();

        var property = Object.getOwnPropertyDescriptor(obj, key);
        if (property && property.configurable === false) {
            return
        }
        //The Object.getOwnPropertyDescriptor()  获取自身的属性 而不是从原型链上获取
        // method returns a property descriptor for an own property (that is, one directly present on an object and
        // not in the object's prototype chain) of a given object.

        // cater for pre-defined getter/setters  // 获取预先定义的getter/setters
        var getter = property && property.get;
        var setter = property && property.set;

        var childOb = !shallow && observe(val);
        Object.defineProperty(obj, key, {
            enumerable: true,
            configurable: true,
            get: function reactiveGetter () {  // 每个属性下都会绑定get和set方法
                var value = getter ? getter.call(obj) : val;
                if (Dep.target) {  //pushTarget() 执行这个方法后  Dep.target 才会有Watcher这个对象
                    dep.depend();
                    if (childOb) {
                        childOb.dep.depend();
                        if (Array.isArray(value)) {
                            dependArray(value);
                        }
                    }
                }
                return value
            },
            set: function reactiveSetter (newVal) {
                var value = getter ? getter.call(obj) : val;
                /* eslint-disable no-self-compare */
                if (newVal === value || (newVal !== newVal && value !== value)) {
                    return
                }
                /* eslint-enable no-self-compare */
                if ("development" !== 'production' && customSetter) {
                    customSetter();
                }
                if (setter) {
                    setter.call(obj, newVal);
                } else {
                    val = newVal;
                }
                childOb = !shallow && observe(newVal);
                dep.notify();  // 通知订阅obersver的dep 更新视图  dep 通知watcher 改变视图
            }
        });
    }

    var observeObj = {content:"234",id:"423"}
    var obsObj = new Observer(observeObj)
    var akl = obsObj.value  // 自动执行get方法
    obsObj.value.content = "132" // 自动执行set方法

    /**
     * Set a property on an object. Adds the new property and
     * triggers change notification if the property doesn't
     * already exist.
     */
    function set (target, key, val) {
        if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.length = Math.max(target.length, key);
            target.splice(key, 1, val);
            return val
        }
        if (key in target && !(key in Object.prototype)) {
            target[key] = val;
            return val
        }
        var ob = (target).__ob__;
        if (target._isVue || (ob && ob.vmCount)) {
            "development" !== 'production' && warn(  // 不要用vue下的实例属性
                    'Avoid adding reactive properties to a Vue instance or its root $data ' +
                    'at runtime - declare it upfront in the data option.'
            );
            return val
        }
        if (!ob) {
            target[key] = val;
            return val
        }
        defineReactive(ob.value, key, val);
        ob.dep.notify();
        return val
    }
    /**
     * Option overwriting strategies are functions that handle  合并参数的值 策略模式
     * how to merge a parent option value and a child option
     * value into the final value.
     */
    var strats = config.optionMergeStrategies;

    /**
     * Options with restrictions
     */
    {
        strats.el = strats.propsData = function (parent, child, vm, key) {
            if (!vm) {
                warn(
                        "option \"" + key + "\" can only be used during instance " +
                        'creation with the `new` keyword.'
                );
            }
            return defaultStrat(parent, child)
        };
    }
    /**
     * Helper that recursively merges two data objects together.
     */
    function mergeData (to, from) {
        if (!from) { return to }
        var key, toVal, fromVal;
        var keys = Object.keys(from);
        for (var i = 0; i < keys.length; i++) {
            key = keys[i];
            toVal = to[key];
            fromVal = from[key];
            if (!hasOwn(to, key)) {
                set(to, key, fromVal);
            } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
                mergeData(toVal, fromVal); // 递归调用
            }
        }
        return to
    }
    // console.log(mergeData({dk:"132"},{abc:"123132"})) {dk: "132", abc: "123132"}
    // console.log(mergeData ({dk:"132"}, obsObj))

    /**
     * Delete a property and trigger change if necessary.
     */
    function del (target, key) {
        if (Array.isArray(target) && isValidArrayIndex(key)) {
            target.splice(key, 1);
            return
        }
        var ob = (target).__ob__;
        if (target._isVue || (ob && ob.vmCount)) {
            "development" !== 'production' && warn(
                    'Avoid deleting properties on a Vue instance or its root $data ' +
                    '- just set it to null.'
            );
            return
        }
        if (!hasOwn(target, key)) {
            return
        }
        delete target[key];
        if (!ob) {
            return
        }
        ob.dep.notify();
    }

    /**
     * Data
     */
    function mergeDataOrFn (  //  如果是函数 那么该函数应该返回一个对象进行合并  最后调用mergeData 返回合并数据
            parentVal,
            childVal,
            vm
    ) {
        if (!vm) {
            // in a Vue.extend merge, both should be functions
            if (!childVal) {
                return parentVal
            }
            if (!parentVal) {
                return childVal
            }
            // when parentVal & childVal are both present,
            // we need to return a function that returns the
            // merged result of both functions... no need to
            // check if parentVal is a function here because
            // it has to be a function to pass previous merges.
            return function mergedDataFn () {
                console.log(this,parentVal)
                return mergeData(
                        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
                        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
                )
            }
        } else {
            return function mergedInstanceDataFn () {
                // instance merge
                var instanceData = typeof childVal === 'function'
                        ? childVal.call(vm, vm)
                        : childVal;
                var defaultData = typeof parentVal === 'function'
                        ? parentVal.call(vm, vm)
                        : parentVal;
                if (instanceData) {
                    return mergeData(instanceData, defaultData)
                } else {
                    return defaultData
                }
            }
        }
    }

    strats.data = function (
            parentVal,
            childVal,
            vm
    ) {
        if (!vm) {
            if (childVal && typeof childVal !== 'function') {
                "development" !== 'production' && warn(
                        'The "data" option should be a function ' +
                        'that returns a per-instance value in component ' +
                        'definitions.',  // 数据的参数应该是一个函数，并且返回每个实例下的值 在vue组件中
                        vm
                );

                return parentVal
            }
            return mergeDataOrFn(parentVal, childVal)
        }

        return mergeDataOrFn(parentVal, childVal, vm)
    };
    /**
     * Hooks and props are merged as arrays.
     */
    function mergeHook (
            parentVal,
            childVal
    ) {
        return childVal
                ? parentVal
                ? parentVal.concat(childVal)
                : Array.isArray(childVal)
                ? childVal
                : [childVal]
                : parentVal
    }
    var dos = true;
    var doss = void (0);
    // console.log(dos ? doss ? 123 : dos ? 543 : 234 : 324)
    // dos = false  324
    // dos = true  如果？前的表达式为真 则返回 如果为假 并且还有表达式 则继续往下判断？
    // console.log(dos ? dos ? 123 : undefined ? undefined : 234 : 324)  123
    // console.log(dos ? doss ? 123 : undefined ? undefined : 234 : 324) 234
    // console.log(dos ? doss ? 123 : dos ? 543 : 234 : 324)  543

    LIFECYCLE_HOOKS.forEach(function (hook) {
        strats[hook] = strats[hook] = mergeHook;
    });
    // console.log(strats['beforeCreate']) mergeHook

    /**
     * Assets
     *
     * When a vm is present (instance creation), we need to do
     * a three-way merge between constructor options, instance
     * options and parent options.
     */
    function mergeAssets (
            parentVal,
            childVal,
            vm,
            key
    ) {
        var res = Object.create(parentVal || null);
        if (childVal) {
            "development" !== 'production' && assertObjectType(key, childVal, vm);
            return extend(res, childVal) //拷贝
        } else {
            return res
        }
    }
   //var ASSET_TYPES = ['component','directive','filter'];
    ASSET_TYPES.forEach(function (type) {
        strats[type + 's'] = mergeAssets;
    });
    // console.log(strats['components'])  mergeAssets

    /**
     * Watchers.
     *
     * Watchers hashes should not overwrite one
     * another, so we merge them as arrays.
     */
    strats.watch = function (
            parentVal,
            childVal,
            vm,
            key
    ) {
        // work around Firefox's Object.prototype.watch...
        if (parentVal === nativeWatch) { parentVal = undefined; }
        if (childVal === nativeWatch) { childVal = undefined; }
        /* istanbul ignore if */
        if (!childVal) { return Object.create(parentVal || null) }
        {
            assertObjectType(key, childVal, vm);
        }
        if (!parentVal) { return childVal }
        var ret = {};
        extend(ret, parentVal);
        for (var key$1 in childVal) {
            var parent = ret[key$1];
            var child = childVal[key$1];
            if (parent && !Array.isArray(parent)) {
                parent = [parent];
            }
            ret[key$1] = parent
                    ? parent.concat(child)
                    : Array.isArray(child) ? child : [child];
        }
        return ret
    };

    /**
     * Other object hashes.
     */
    strats.props =
            strats.methods =
                    strats.inject =
                            strats.computed = function (
                                    parentVal,
                                    childVal,
                                    vm,
                                    key
                            ) {
                                if (childVal && "development" !== 'production') {
                                    assertObjectType(key, childVal, vm);
                                }
                                if (!parentVal) { return childVal }
                                var ret = Object.create(null);
                                extend(ret, parentVal);
                                if (childVal) { extend(ret, childVal); }
                                return ret
                            };
    strats.provide = mergeDataOrFn;

    /**
     * Default strategy.
     */
    var defaultStrat = function (parentVal, childVal) {
        return childVal === undefined
                ? parentVal
                : childVal
    };

    /**
     * Validate component names
     */
    function checkComponents (options) {
        for (var key in options.components) {
            validateComponentName(key);
        }
    }

    function validateComponentName (name) {
        if (!/^[a-zA-Z][\w-]*$/.test(name)) {
            warn(
                    'Invalid component name: "' + name + '". Component names ' +
                    'can only contain alphanumeric characters and the hyphen, ' +
                    'and must start with a letter.'
            );
        }
        if (isBuiltInTag(name) || config.isReservedTag(name)) {
            warn(
                    'Do not use built-in or reserved HTML elements as component ' + //不要使用内置的或保留的HTML元素作为组件。
                    'id: ' + name
            );
        }
    }

    /**
     * Ensure all props option syntax are normalized into the
     * Object-based format.
     */
    function normalizeProps (options, vm) {
        var props = options.props;
        if (!props) { return }
        var res = {};
        var i, val, name;
        if (Array.isArray(props)) {
            i = props.length;
            while (i--) {
                val = props[i];
                if (typeof val === 'string') {
                    name = camelize(val);
                    res[name] = { type: null };
                } else {
                    warn('props must be strings when using array syntax.');
                }
            }
        } else if (isPlainObject(props)) {
            for (var key in props) {
                val = props[key];
                name = camelize(key);
                res[name] = isPlainObject(val)
                        ? val
                        : { type: val };
            }
        } else {
            warn(
                    "Invalid value for option \"props\": expected an Array or an Object, " +
                    "but got " + (toRawType(props)) + ".",
                    vm
            );
        }
        options.props = res;
    }

    /**
     * Normalize all injections into Object-based format 将所有注入的组件标准化为基于对象的格式
     */
    function normalizeInject (options, vm) {
        var inject = options.inject;
        if (!inject) { return }
        var normalized = options.inject = {};
        if (Array.isArray(inject)) {
            for (var i = 0; i < inject.length; i++) {
                normalized[inject[i]] = { from: inject[i] };
            }
        } else if (isPlainObject(inject)) {
            for (var key in inject) {
                var val = inject[key];
                normalized[key] = isPlainObject(val)
                        ? extend({ from: key }, val)
                        : { from: val };
            }
        } else {
            warn(
                    "Invalid value for option \"inject\": expected an Array or an Object, " +
                    "but got " + (toRawType(inject)) + ".",
                    vm
            );
        }
    }

    /**
     * Normalize raw function directives into object format.
     */
    function normalizeDirectives (options) {
        var dirs = options.directives;
        if (dirs) {
            for (var key in dirs) {
                var def = dirs[key];
                if (typeof def === 'function') {
                    dirs[key] = { bind: def, update: def };
                }
            }
        }
    }

    function assertObjectType (name, value, vm) {
        if (!isPlainObject(value)) {
            warn(
                    "Invalid value for option \"" + name + "\": expected an Object, " +
                    "but got " + (toRawType(value)) + ".",
                    vm
            );
        }
    }

    /**
     * Merge two option objects into a new one.
     * Core utility used in both instantiation and inheritance. 采取策略模式 合并参数 核心函数
     */
    function mergeOptions (
            parent,
            child,
            vm
    ) {
        {
            checkComponents(child);
        }

        if (typeof child === 'function') {
            child = child.options;
        }

        normalizeProps(child, vm);
        normalizeInject(child, vm);
        normalizeDirectives(child);
        var extendsFrom = child.extends; //{name: "1132"} undefined
        if (extendsFrom) {
            parent = mergeOptions(parent, extendsFrom, vm);
        }
        if (child.mixins) {  // 如果有混合 则遍历混合的对象 入侵注入vue
            for (var i = 0, l = child.mixins.length; i < l; i++) {
                parent = mergeOptions(parent, child.mixins[i], vm);
            }
        }
        var options = {};
        var key;
        for (key in parent) {
            mergeField(key);
        }
        for (key in child) {
            if (!hasOwn(parent, key)) {
                mergeField(key);
            }
        }
        function mergeField (key) {
            // console.log(strats)
            var strat = strats[key] || defaultStrat;
            options[key] = strat(parent[key], child[key], vm, key);  // 最终调用的是mergeData 方法
        }
        return options
    }
    var o = mergeOptions({akd:"12"},{
        extends:{name:"1132"},
        'aaa':{
            data:function(){
                return{
                    msg:'父组件'
                }
            },
            methods:{
                test:function(){
                    alert("我是父组件")
                }
            },
            template:'#temA',/*父组件的模板*/
            components:{
                'bbb':{
                    template:"<h3>我是子组件</h3>"
                }
            }
        }
    },vue)
    //  console.log(o)
    // {akd: "12", aaa: {…}}

    // 模拟执行顺序 在new之前就已经执行了初始化的函数 以及配置
    function dk () {/*console.log(12)*/}
    function ada (options) { dk () }
    dk()
    var k = new ada({name:"32"})


    // vue.$options.components = o   4530行 vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor),options || {},vm);  4650 开始初始化参数
    // 在初始化之前 vue已经把相关的变量 函数 以及基本的参数设置 进行完毕
    // console.log(vue)

    //function vue() {} vue.options 当new vue()时  options属性是挂载在他的构造函数(constrcutor) 下 当var Vue = new vue()时 Vue.$options 是挂载在他的实例属性下

    /**
     * Resolve an asset.
     * This function is used because child instances need access
     * to assets defined in its ancestor chain.
     */
    function resolveAsset (
            options,
            type,
            id,
            warnMissing
    ) {
        /* istanbul ignore if */
        if (typeof id !== 'string') {
            return
        }
        var assets = options[type];
        // check local registration variations first
        if (hasOwn(assets, id)) { return assets[id] }
        var camelizedId = camelize(id);
        if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
        var PascalCaseId = capitalize(camelizedId);
        if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
        // fallback to prototype chain
        var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
        if ("development" !== 'production' && warnMissing && !res) {
            warn(
                    'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
                    options
            );
        }
        return res
    }

    // resolveAsset({
    // conmponents:{ aaa:{},data:{}},
    // directives:{},...
    // },'conmponents','aaa')


    /*  */

    function validateProp (
            key,
            propOptions,
            propsData,
            vm
    ) {
        var prop = propOptions[key];
        var absent = !hasOwn(propsData, key);
        var value = propsData[key];
        //  handle boolean props
        if (isType(Boolean, prop.type)) {
            if (absent && !hasOwn(prop, 'default')) {
                value = false;
            } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
                value = true;
            }
        }
        // check default value
        if (value === undefined) {
            value = getPropDefaultValue(vm, prop, key);
            // since the default value is a fresh copy,
            // make sure to observe it.
            var prevShouldConvert = observerState.shouldConvert;
            observerState.shouldConvert = true;
            observe(value);
            observerState.shouldConvert = prevShouldConvert;
        }
        {
            assertProp(prop, key, value, vm, absent);
        }
        return value
    }

    /**
     * Get the default value of a prop.
     */
    function getPropDefaultValue (vm, prop, key) {
        // no default, return undefined
        if (!hasOwn(prop, 'default')) {
            return undefined
        }
        var def = prop.default;
        // warn against non-factory defaults for Object & Array
        if ("development" !== 'production' && isObject(def)) {
            warn(
                    'Invalid default value for prop "' + key + '": ' +
                    'Props with type Object/Array must use a factory function ' +
                    'to return the default value.',
                    vm
            );
        }
        // the raw prop value was also undefined from previous render,
        // return previous default value to avoid unnecessary watcher trigger
        if (vm && vm.$options.propsData &&
                vm.$options.propsData[key] === undefined &&
                vm._props[key] !== undefined
        ) {
            return vm._props[key]
        }
        // call factory function for non-Function types
        // a value is Function if its prototype is function even across different execution context
        return typeof def === 'function' && getType(prop.type) !== 'Function'
                ? def.call(vm)
                : def
    }

    /**
     * Assert whether a prop is valid.
     */
    function assertProp (
            prop,
            name,
            value,
            vm,
            absent
    ) {
        if (prop.required && absent) {
            warn(
                    'Missing required prop: "' + name + '"',
                    vm
            );
            return
        }
        if (value == null && !prop.required) {
            return
        }
        var type = prop.type;
        var valid = !type || type === true;
        var expectedTypes = [];
        if (type) {
            if (!Array.isArray(type)) {
                type = [type];
            }
            for (var i = 0; i < type.length && !valid; i++) {
                var assertedType = assertType(value, type[i]);
                expectedTypes.push(assertedType.expectedType || '');
                valid = assertedType.valid;
            }
        }
        if (!valid) {
            warn(
                    "Invalid prop: type check failed for prop \"" + name + "\"." +
                    " Expected " + (expectedTypes.map(capitalize).join(', ')) +
                    ", got " + (toRawType(value)) + ".",
                    vm
            );
            return
        }
        var validator = prop.validator;
        if (validator) {
            if (!validator(value)) {
                warn(
                        'Invalid prop: custom validator check failed for prop "' + name + '".',
                        vm
                );
            }
        }
    }

    var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

    function assertType (value, type) {
        var valid;
        var expectedType = getType(type);
        if (simpleCheckRE.test(expectedType)) {
            var t = typeof value;
            valid = t === expectedType.toLowerCase();
            // for primitive wrapper objects
            if (!valid && t === 'object') {
                valid = value instanceof type;
            }
        } else if (expectedType === 'Object') {
            valid = isPlainObject(value);
        } else if (expectedType === 'Array') {
            valid = Array.isArray(value);
        } else {
            valid = value instanceof type;
        }
        return {
            valid: valid,
            expectedType: expectedType
        }
    }

    /**
     * Use function string name to check built-in types,
     * because a simple equality check will fail when running
     * across different vms / iframes.
     */
    function getType (fn) {
        var match = fn && fn.toString().match(/^\s*function (\w+)/);
        return match ? match[1] : ''
    }

    function isType (type, fn) {
        if (!Array.isArray(fn)) {
            return getType(fn) === getType(type)
        }
        for (var i = 0, len = fn.length; i < len; i++) {
            if (getType(fn[i]) === getType(type)) {
                return true
            }
        }
        /* istanbul ignore next */
        return false
    }

    /*  */

    function handleError (err, vm, info) {
        if (vm) {
            var cur = vm;
            while ((cur = cur.$parent)) {
                var hooks = cur.$options.errorCaptured;
                if (hooks) {
                    for (var i = 0; i < hooks.length; i++) {
                        try {
                            var capture = hooks[i].call(cur, err, vm, info) === false;
                            if (capture) { return }
                        } catch (e) {
                            globalHandleError(e, cur, 'errorCaptured hook');
                        }
                    }
                }
            }
        }
        globalHandleError(err, vm, info);
    }

    function globalHandleError (err, vm, info) {
        if (config.errorHandler) {
            try {
                return config.errorHandler.call(null, err, vm, info)
            } catch (e) {
                logError(e, null, 'config.errorHandler');
            }
        }
        logError(err, vm, info);
    }

    function logError (err, vm, info) {
        {
            warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
        }
        /* istanbul ignore else */
        if ((inBrowser || inWeex) && typeof console !== 'undefined') {
            console.error(err);
        } else {
            throw err
        }
    }

    /*  */
    /* globals MessageChannel */

    var callbacks = [];
    var pending = false;

    function flushCallbacks () {
        pending = false;
        var copies = callbacks.slice(0);
        callbacks.length = 0;
        for (var i = 0; i < copies.length; i++) {
            copies[i]();
        }
    }

    // Here we have async deferring wrappers using both micro and macro tasks.
    // In < 2.4 we used micro tasks everywhere, but there are some scenarios where
    // micro tasks have too high a priority and fires in between supposedly
    // sequential events (e.g. #4521, #6690) or even between bubbling of the same
    // event (#6566). However, using macro tasks everywhere also has subtle problems
    // when state is changed right before repaint (e.g. #6813, out-in transitions).
    // Here we use micro task by default, but expose a way to force macro task when
    // needed (e.g. in event handlers attached by v-on).
    var microTimerFunc;
    var macroTimerFunc;
    var useMacroTask = false;

    // Determine (macro) Task defer implementation.
    // Technically setImmediate should be the ideal choice, but it's only available
    // in IE. The only polyfill that consistently queues the callback after all DOM
    // events triggered in the same loop is by using MessageChannel.
    /* istanbul ignore if */
    if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
        macroTimerFunc = function () {
            setImmediate(flushCallbacks);
        };
    } else if (typeof MessageChannel !== 'undefined' && (
                    isNative(MessageChannel) ||
                    // PhantomJS
                    MessageChannel.toString() === '[object MessageChannelConstructor]'
            )) {
        var channel = new MessageChannel();
        //console.log(channel)MessageChannel {port1: MessagePort, port2: MessagePort}port1: MessagePort {onmessage: ƒ, onmessageerror: null}port2: MessagePort {onmessage: null, onmessageerror: null}__proto__: MessageChannel
        var port = channel.port2;
        channel.port1.onmessage = flushCallbacks;
        macroTimerFunc = function () {
            port.postMessage(1);
        };
    } else {
        /* istanbul ignore next */
        macroTimerFunc = function () {
            setTimeout(flushCallbacks, 0);
        };
    }

    // Determine MicroTask defer implementation.
    /* istanbul ignore next, $flow-disable-line */
    if (typeof Promise !== 'undefined' && isNative(Promise)) {
        var p = Promise.resolve();
        microTimerFunc = function () {
            p.then(flushCallbacks);
            // in problematic UIWebViews, Promise.then doesn't completely break, but
            // it can get stuck in a weird state where callbacks are pushed into the
            // microtask queue but the queue isn't being flushed, until the browser
            // needs to do some other work, e.g. handle a timer. Therefore we can
            // "force" the microtask queue to be flushed by adding an empty timer.
            if (isIOS) { setTimeout(noop); }
        };
    } else {
        // fallback to macro
        microTimerFunc = macroTimerFunc;
    }
    //console.log(Promise.resolve())

    /**
     * Wrap a function so that if any code inside triggers state change,
     * the changes are queued using a Task instead of a MicroTask.
     */
    function withMacroTask (fn) {
        return fn._withTask || (fn._withTask = function () {
                    useMacroTask = true;
                    var res = fn.apply(null, arguments);
                    useMacroTask = false;
                    return res
                })
    }

    function nextTick (cb, ctx) {
        var _resolve;
        callbacks.push(function () {
            if (cb) {
                try {
                    cb.call(ctx);
                } catch (e) {
                    handleError(e, ctx, 'nextTick');
                }
            } else if (_resolve) {
                _resolve(ctx);
            }
        });
        if (!pending) {
            pending = true;
            if (useMacroTask) {
                macroTimerFunc();
            } else {
                microTimerFunc();
            }
        }
        // $flow-disable-line
        if (!cb && typeof Promise !== 'undefined') {
            return new Promise(function (resolve) {
                _resolve = resolve;
            })
        }
    }

    /*  */
    // https://www.cnblogs.com/bldxh/p/6857324.html
    var mark;
    var measure;

    {
        var perf = inBrowser && window.performance; //performance 前端性能监控
        console.log(perf.clearMarks)
        /* istanbul ignore if */
        if (
                perf &&
                perf.mark &&  //通过mark()方法添加到数组中的对象
                perf.measure && //	通过measure()方法添加到数组中的对象
                perf.clearMarks && //清除所有标记(name) 清除指定标记
                perf.clearMeasures //清除指定记录间隔数据
        ) {
            mark = function (tag) { return perf.mark(tag); };
            measure = function (name, startTag, endTag) {
                perf.measure(name, startTag, endTag);
                perf.clearMarks(startTag);
                perf.clearMarks(endTag);
                perf.clearMeasures(name);
            };
        }
    }
    /* not type checking this file because flow doesn't play well with Proxy */

    var initProxy;

    {
        var allowedGlobals = makeMap(
                'Infinity,undefined,NaN,isFinite,isNaN,' +
                'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
                'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
                'require' // for Webpack/Browserify
        );

        var warnNonPresent = function (target, key) {
            warn(
                    "Property or method \"" + key + "\" is not defined on the instance but " +
                    'referenced during render. Make sure that this property is reactive, ' +
                    'either in the data option, or for class-based components, by ' +
                    'initializing the property. ' +
                    'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
                    target
            );
        };

        var hasProxy =
                typeof Proxy !== 'undefined' &&
                Proxy.toString().match(/native code/);

        if (hasProxy) {
            var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
            config.keyCodes = new Proxy(config.keyCodes, {
                set: function set (target, key, value) {
                    if (isBuiltInModifier(key)) {
                        warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
                        return false
                    } else {
                        target[key] = value;
                        return true
                    }
                }
            });
        }

        var hasHandler = {
            has: function has (target, key) {
                var has = key in target;
                var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
                if (!has && !isAllowed) {
                    warnNonPresent(target, key);
                }
                return has || !isAllowed
            }
        };

        var getHandler = {
            get: function get (target, key) {
                if (typeof key === 'string' && !(key in target)) {
                    warnNonPresent(target, key);
                }
                return target[key]
            }
        };

        initProxy = function initProxy (vm) {
            if (hasProxy) {
                // determine which proxy handler to use
                var options = vm.$options;
                var handlers = options.render && options.render._withStripped
                        ? getHandler
                        : hasHandler;
                vm._renderProxy = new Proxy(vm, handlers);
            } else {
                vm._renderProxy = vm;
            }
        };
    }











</script>
</body>
</html>